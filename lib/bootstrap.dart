// Kylos IPTV Player - Bootstrap
// Shared initialization logic for all platform entry points.

import 'dart:async';

import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:kylos_iptv_player/app.dart';
import 'package:kylos_iptv_player/core/auth/auth_service.dart';
import 'package:kylos_iptv_player/core/platform/form_factor.dart';
import 'package:kylos_iptv_player/core/user/user_repository.dart';
import 'package:kylos_iptv_player/features/live_tv/data/repositories/mock_epg_repository.dart';
import 'package:kylos_iptv_player/features/live_tv/data/repositories/playlist_channel_repository.dart';
import 'package:kylos_iptv_player/features/live_tv/presentation/providers/channel_providers.dart';
import 'package:kylos_iptv_player/features/playlists/presentation/providers/playlist_providers.dart';
import 'package:kylos_iptv_player/features/series/data/repositories/playlist_series_repository.dart';
import 'package:kylos_iptv_player/features/series/presentation/providers/series_providers.dart';
import 'package:kylos_iptv_player/features/vod/data/repositories/playlist_vod_repository.dart';
import 'package:kylos_iptv_player/features/vod/presentation/providers/vod_providers.dart';
import 'package:kylos_iptv_player/core/domain/watch_history/watch_history_providers.dart';
import 'package:kylos_iptv_player/infrastructure/repositories/hybrid_watch_history_repository.dart';
import 'package:kylos_iptv_player/infrastructure/repositories/local_watch_history_repository.dart';
import 'package:kylos_iptv_player/infrastructure/firebase/firebase_initializer.dart';
import 'package:kylos_iptv_player/infrastructure/firebase/firebase_providers.dart';
import 'package:kylos_iptv_player/infrastructure/providers/infrastructure_providers.dart'
    as infra;
import 'package:kylos_iptv_player/infrastructure/repositories/local_playlist_repository.dart';
import 'package:kylos_iptv_player/infrastructure/storage/local_storage.dart';
import 'package:kylos_iptv_player/shared/providers/platform_providers.dart';
import 'package:kylos_iptv_player/features/ads/presentation/providers/ad_providers.dart';
import 'package:kylos_iptv_player/core/analytics/firebase_analytics_service.dart';
import 'package:media_kit/media_kit.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Firebase configuration options generated from Firebase Console settings.
import 'package:kylos_iptv_player/firebase_options.dart';

/// Bootstrap the application with the specified form factor.
///
/// This function handles all initialization logic including:
/// - Flutter bindings initialization
/// - Error handling configuration
/// - Platform-specific setup
/// - Provider container creation
Future<void> bootstrap({
  required FormFactor formFactor,
  FirebaseOptions? firebaseOptions,
}) async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize media_kit for video playback
  MediaKit.ensureInitialized();

  // Configure error handling
  _configureErrorHandling();

  // Configure orientation - always landscape for IPTV player
  await _configureOrientation();

  // Initialize SharedPreferences
  final sharedPreferences = await SharedPreferences.getInstance();

  // Initialize Firebase
  // Pass firebase_options.dart DefaultFirebaseOptions.currentPlatform
  // when generated by FlutterFire CLI.
  final firebaseResult = await FirebaseInitializer.instance.initialize(
    options: firebaseOptions,
  );

  if (!firebaseResult.success) {
    if (kDebugMode) {
      print('Firebase initialization failed: ${firebaseResult.error}');
      print('App will continue with limited functionality.');
    }
  }

  // Create local storage and playlist repository
  final localStorage = LocalStorage(preferences: sharedPreferences);
  final playlistRepository = LocalPlaylistRepository(localStorage: localStorage);

  // Create real channel repository, VOD repository, series repository, and mock EPG repository
  final channelRepository = PlaylistChannelRepository(localStorage: localStorage);
  final vodRepository = PlaylistVodRepository(localStorage: localStorage);
  final seriesRepository = PlaylistSeriesRepository(localStorage: localStorage);
  final epgRepository = MockEpgRepository();
  final localWatchHistoryRepository = LocalWatchHistoryRepository(localStorage: localStorage);
  // Use hybrid repository for cross-device resume support
  final watchHistoryRepository = HybridWatchHistoryRepository(
    localRepository: localWatchHistoryRepository,
  );

  // Create provider container with platform overrides
  final container = ProviderContainer(
    overrides: [
      formFactorProvider.overrideWithValue(formFactor),
      infra.sharedPreferencesProvider.overrideWithValue(sharedPreferences),
      playlistRepositoryProvider.overrideWithValue(playlistRepository),
      playlistChannelRepositoryProvider.overrideWithValue(channelRepository),
      playlistVodRepositoryProvider.overrideWithValue(vodRepository),
      playlistSeriesRepositoryProvider.overrideWithValue(seriesRepository),
      epgRepositoryProvider.overrideWithValue(epgRepository),
      watchHistoryRepositoryProvider.overrideWithValue(watchHistoryRepository),
    ],
  );

  // Load playlists from storage
  await container.read(playlistsNotifierProvider.notifier).loadPlaylists();

  // Load active playlist from storage
  await container.read(activePlaylistNotifierProvider.notifier).loadActivePlaylist();

  // Set active playlist on channel repository
  final activePlaylist = container.read(activePlaylistProvider);
  if (activePlaylist != null) {
    await channelRepository.setPlaylistSource(activePlaylist);
  }

  // Initialize remote config service
  if (firebaseResult.success) {
    await container.read(remoteConfigServiceProvider).initialize();

    // Sign in anonymously if no user is signed in
    await _ensureAuthenticated(container);

    // Initialize Firebase Analytics
    await _initializeAnalytics(container);
  }

  // Initialize ads service (works independently of Firebase auth)
  await _initializeAds(container);

  // Run the app
  runApp(
    UncontrolledProviderScope(
      container: container,
      child: const KylosApp(),
    ),
  );
}

/// Ensures the user is authenticated.
///
/// Signs in anonymously if no user is currently signed in.
/// Creates user document in Firestore on first sign-in.
/// This is non-blocking - Firestore errors won't prevent app startup.
Future<void> _ensureAuthenticated(ProviderContainer container) async {
  try {
    final authService = container.read(authServiceProvider);

    // Check if already signed in
    if (authService.currentUser != null) {
      // Update last login timestamp (fire and forget - don't block on Firestore)
      final userRepo = container.read(userRepositoryProvider);
      if (userRepo != null) {
        unawaited(_updateLastLoginSafe(userRepo, authService.currentUser!.uid));
      }
      return;
    }

    // Sign in anonymously with timeout
    final result = await authService.signInAnonymously().timeout(
      const Duration(seconds: 10),
      onTimeout: () {
        if (kDebugMode) {
          print('Anonymous sign-in timed out');
        }
        return const AuthFailure('timeout', 'Sign-in timed out');
      },
    );

    if (result is AuthSuccess) {
      if (kDebugMode) {
        print('Signed in anonymously: ${result.user.uid}');
      }

      // Create user document in background (fire and forget - don't block startup)
      final userRepo = container.read(userRepositoryProvider);
      if (userRepo != null) {
        unawaited(_createUserDocumentSafe(userRepo, result.user));
      }
    } else if (result is AuthFailure && kDebugMode) {
      print('Anonymous sign-in failed: ${result.message}');
    }
  } catch (e) {
    // Don't let authentication issues prevent app startup
    if (kDebugMode) {
      print('Authentication error (non-fatal): $e');
    }
  }
}

/// Safely update last login without blocking.
Future<void> _updateLastLoginSafe(UserRepository userRepo, String userId) async {
  try {
    await userRepo.updateLastLogin(userId).timeout(
      const Duration(seconds: 5),
      onTimeout: () {
        if (kDebugMode) {
          print('Update last login timed out');
        }
      },
    );
  } catch (e) {
    if (kDebugMode) {
      print('Failed to update last login (non-fatal): $e');
    }
  }
}

/// Safely create user document without blocking.
Future<void> _createUserDocumentSafe(UserRepository userRepo, AppUser user) async {
  try {
    final exists = await userRepo.userExists(user.uid).timeout(
      const Duration(seconds: 5),
      onTimeout: () => true, // Assume exists on timeout to avoid duplicate creation
    );
    if (!exists) {
      await userRepo.createUser(
        UserDocument(
          uid: user.uid,
          email: user.email,
          displayName: user.displayName,
          photoUrl: user.photoUrl,
          createdAt: DateTime.now(),
          lastLoginAt: DateTime.now(),
          providers: user.providers,
          preferences: const UserPreferences(),
        ),
      ).timeout(
        const Duration(seconds: 5),
        onTimeout: () {
          if (kDebugMode) {
            print('Create user document timed out');
          }
        },
      );
    }
  } catch (e) {
    if (kDebugMode) {
      print('Failed to create user document (non-fatal): $e');
    }
  }
}

void _configureErrorHandling() {
  // Pass Flutter errors to error reporting service
  FlutterError.onError = (details) {
    FlutterError.presentError(details);
    if (!kDebugMode) {
      // TODO: Report to Crashlytics when Firebase is integrated
      // FirebaseCrashlytics.instance.recordFlutterFatalError(details);
    }
  };

  // Pass async errors to error reporting service
  PlatformDispatcher.instance.onError = (error, stack) {
    if (!kDebugMode) {
      // TODO: Report to Crashlytics when Firebase is integrated
      // FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
    }
    return true;
  };
}

Future<void> _configureOrientation() async {
  // IPTV player is always landscape for optimal viewing experience
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.landscapeLeft,
    DeviceOrientation.landscapeRight,
  ]);
}

/// Initialize Firebase Analytics service.
Future<void> _initializeAnalytics(ProviderContainer container) async {
  try {
    final analyticsService = FirebaseAnalyticsService();
    await analyticsService.initialize();

    // Log app open event
    await analyticsService.logEvent('app_open', {
      'platform': defaultTargetPlatform.name,
    });

    if (kDebugMode) {
      print('Firebase Analytics initialized');
    }
  } catch (e) {
    if (kDebugMode) {
      print('Failed to initialize analytics (non-fatal): $e');
    }
  }
}

/// Initialize ads service (AdMob).
Future<void> _initializeAds(ProviderContainer container) async {
  try {
    final adService = container.read(adServiceProvider);
    final initialized = await adService.initialize();

    if (initialized) {
      // Pre-load an interstitial ad for later use
      await adService.loadInterstitial();

      if (kDebugMode) {
        print('Ads service initialized and interstitial preloaded');
      }
    } else if (kDebugMode) {
      print('Ads service not available on this platform');
    }
  } catch (e) {
    if (kDebugMode) {
      print('Failed to initialize ads (non-fatal): $e');
    }
  }
}
